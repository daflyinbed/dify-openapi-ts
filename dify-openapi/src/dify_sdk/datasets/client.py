# This file was auto-generated by Fern from our API Definition.

import typing
from ..core.client_wrapper import SyncClientWrapper
from ..core.request_options import RequestOptions
from ..types.dataset_list import DatasetList
from ..core.pydantic_utilities import parse_obj_as
from ..errors.bad_request_error import BadRequestError
from ..types.error import Error
from json.decoder import JSONDecodeError
from ..core.api_error import ApiError
from .types.create_dataset_request_indexing_technique import (
    CreateDatasetRequestIndexingTechnique,
)
from .types.create_dataset_request_permission import CreateDatasetRequestPermission
from .types.create_dataset_request_provider import CreateDatasetRequestProvider
from ..types.dataset import Dataset
from ..errors.conflict_error import ConflictError
from ..core.jsonable_encoder import jsonable_encoder
from ..errors.forbidden_error import ForbiddenError
from .types.patch_datasets_dataset_id_request_indexing_technique import (
    PatchDatasetsDatasetIdRequestIndexingTechnique,
)
from .types.patch_datasets_dataset_id_request_permission import (
    PatchDatasetsDatasetIdRequestPermission,
)
from .types.retrieve_dataset_request_retrieval_model import (
    RetrieveDatasetRequestRetrievalModel,
)
from .types.retrieve_dataset_response import RetrieveDatasetResponse
from ..core.serialization import convert_and_respect_annotation_metadata
from ..core.client_wrapper import AsyncClientWrapper

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class DatasetsClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._client_wrapper = client_wrapper

    def get_dataset_list(
        self,
        *,
        page: typing.Optional[int] = None,
        limit: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> DatasetList:
        """
        Get a list of all knowledge bases

        Parameters
        ----------
        page : typing.Optional[int]
            Page number

        limit : typing.Optional[int]
            Number of items per page

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        DatasetList
            Successfully retrieved knowledge base list

        Examples
        --------
        from dify import DifyApi

        client = DifyApi(
            token="YOUR_TOKEN",
        )
        client.datasets.get_dataset_list()
        """
        _response = self._client_wrapper.httpx_client.request(
            "datasets",
            method="GET",
            params={
                "page": page,
                "limit": limit,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    DatasetList,
                    parse_obj_as(
                        type_=DatasetList,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def create_empty_dataset(
        self,
        *,
        name: str,
        description: typing.Optional[str] = OMIT,
        indexing_technique: typing.Optional[CreateDatasetRequestIndexingTechnique] = OMIT,
        permission: typing.Optional[CreateDatasetRequestPermission] = OMIT,
        provider: typing.Optional[CreateDatasetRequestProvider] = OMIT,
        external_knowledge_api_id: typing.Optional[str] = OMIT,
        external_knowledge_id: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> Dataset:
        """
        Create a new empty knowledge base

        Parameters
        ----------
        name : str
            Knowledge Base name (required)

        description : typing.Optional[str]
            Knowledge Base description (optional)

        indexing_technique : typing.Optional[CreateDatasetRequestIndexingTechnique]
            Indexing mode (optional, recommended)
            - high_quality: High quality
            - economy: Economy

        permission : typing.Optional[CreateDatasetRequestPermission]
            Permission (optional, default only_me)
            - only_me: Only me
            - all_team_members: All team members
            - partial_members: Partial team members

        provider : typing.Optional[CreateDatasetRequestProvider]
            Provider (optional, default vendor)
            - vendor: Upload files
            - external: External knowledge base

        external_knowledge_api_id : typing.Optional[str]
            External knowledge API_ID (optional)

        external_knowledge_id : typing.Optional[str]
            External knowledge ID (optional)

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        Dataset
            Successfully created knowledge base

        Examples
        --------
        from dify import DifyApi

        client = DifyApi(
            token="YOUR_TOKEN",
        )
        client.datasets.create_empty_dataset(
            name="name",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "datasets",
            method="POST",
            json={
                "name": name,
                "description": description,
                "indexing_technique": indexing_technique,
                "permission": permission,
                "provider": provider,
                "external_knowledge_api_id": external_knowledge_api_id,
                "external_knowledge_id": external_knowledge_id,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    Dataset,
                    parse_obj_as(
                        type_=Dataset,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 409:
                raise ConflictError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def view_knowledge_base_details(
        self,
        dataset_id: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> Dataset:
        """
        Get detailed information about a specific knowledge base

        Parameters
        ----------
        dataset_id : str
            Knowledge Base ID

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        Dataset
            Successfully retrieved knowledge base details

        Examples
        --------
        from dify import DifyApi

        client = DifyApi(
            token="YOUR_TOKEN",
        )
        client.datasets.view_knowledge_base_details(
            dataset_id="dataset_id",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"datasets/{jsonable_encoder(dataset_id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    Dataset,
                    parse_obj_as(
                        type_=Dataset,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def delete_dataset(
        self,
        dataset_id: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> None:
        """
        Delete specified knowledge base

        Parameters
        ----------
        dataset_id : str
            Knowledge Base ID

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        from dify import DifyApi

        client = DifyApi(
            token="YOUR_TOKEN",
        )
        client.datasets.delete_dataset(
            dataset_id="dataset_id",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"datasets/{jsonable_encoder(dataset_id)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def update_knowledge_base_details(
        self,
        dataset_id: str,
        *,
        name: typing.Optional[str] = OMIT,
        indexing_technique: typing.Optional[PatchDatasetsDatasetIdRequestIndexingTechnique] = OMIT,
        permission: typing.Optional[PatchDatasetsDatasetIdRequestPermission] = OMIT,
        embedding_model_provider: typing.Optional[str] = OMIT,
        embedding_model: typing.Optional[str] = OMIT,
        retrieval_model: typing.Optional[str] = OMIT,
        partial_member_list: typing.Optional[typing.Sequence[str]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> Dataset:
        """
        Modify details of a specific knowledge base

        Parameters
        ----------
        dataset_id : str
            Knowledge Base ID

        name : typing.Optional[str]
            Knowledge Base name (optional)

        indexing_technique : typing.Optional[PatchDatasetsDatasetIdRequestIndexingTechnique]
            Indexing mode (optional, recommended)
            - high_quality: High quality
            - economy: Economy

        permission : typing.Optional[PatchDatasetsDatasetIdRequestPermission]
            Permission (optional, default only_me)
            - only_me: Only me
            - all_team_members: All team members
            - partial_members: Partial team members

        embedding_model_provider : typing.Optional[str]
            Embedding model provider (optional), must be configured in the system first, corresponds to the provider field

        embedding_model : typing.Optional[str]
            Embedding model (optional)

        retrieval_model : typing.Optional[str]
            Retrieval model (optional)

        partial_member_list : typing.Optional[typing.Sequence[str]]
            Partial team members ID list (optional)

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        Dataset
            Successfully updated knowledge base details

        Examples
        --------
        from dify import DifyApi

        client = DifyApi(
            token="YOUR_TOKEN",
        )
        client.datasets.update_knowledge_base_details(
            dataset_id="dataset_id",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"datasets/{jsonable_encoder(dataset_id)}",
            method="PATCH",
            json={
                "name": name,
                "indexing_technique": indexing_technique,
                "permission": permission,
                "embedding_model_provider": embedding_model_provider,
                "embedding_model": embedding_model,
                "retrieval_model": retrieval_model,
                "partial_member_list": partial_member_list,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    Dataset,
                    parse_obj_as(
                        type_=Dataset,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def retrieve_dataset(
        self,
        dataset_id: str,
        *,
        query: str,
        retrieval_model: typing.Optional[RetrieveDatasetRequestRetrievalModel] = OMIT,
        external_retrieval_model: typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> RetrieveDatasetResponse:
        """
        Retrieve content from specified knowledge base

        Parameters
        ----------
        dataset_id : str
            Knowledge Base ID

        query : str
            Search keyword

        retrieval_model : typing.Optional[RetrieveDatasetRequestRetrievalModel]
            Retrieval parameter configuration

        external_retrieval_model : typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]]
            Unused field

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        RetrieveDatasetResponse
            Retrieval successful

        Examples
        --------
        from dify import DifyApi

        client = DifyApi(
            token="YOUR_TOKEN",
        )
        client.datasets.retrieve_dataset(
            dataset_id="dataset_id",
            query="query",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"datasets/{jsonable_encoder(dataset_id)}/retrieve",
            method="POST",
            json={
                "query": query,
                "retrieval_model": convert_and_respect_annotation_metadata(
                    object_=retrieval_model,
                    annotation=RetrieveDatasetRequestRetrievalModel,
                    direction="write",
                ),
                "external_retrieval_model": external_retrieval_model,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    RetrieveDatasetResponse,
                    parse_obj_as(
                        type_=RetrieveDatasetResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)


class AsyncDatasetsClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._client_wrapper = client_wrapper

    async def get_dataset_list(
        self,
        *,
        page: typing.Optional[int] = None,
        limit: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> DatasetList:
        """
        Get a list of all knowledge bases

        Parameters
        ----------
        page : typing.Optional[int]
            Page number

        limit : typing.Optional[int]
            Number of items per page

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        DatasetList
            Successfully retrieved knowledge base list

        Examples
        --------
        import asyncio

        from dify import AsyncDifyApi

        client = AsyncDifyApi(
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.datasets.get_dataset_list()


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            "datasets",
            method="GET",
            params={
                "page": page,
                "limit": limit,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    DatasetList,
                    parse_obj_as(
                        type_=DatasetList,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def create_empty_dataset(
        self,
        *,
        name: str,
        description: typing.Optional[str] = OMIT,
        indexing_technique: typing.Optional[CreateDatasetRequestIndexingTechnique] = OMIT,
        permission: typing.Optional[CreateDatasetRequestPermission] = OMIT,
        provider: typing.Optional[CreateDatasetRequestProvider] = OMIT,
        external_knowledge_api_id: typing.Optional[str] = OMIT,
        external_knowledge_id: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> Dataset:
        """
        Create a new empty knowledge base

        Parameters
        ----------
        name : str
            Knowledge Base name (required)

        description : typing.Optional[str]
            Knowledge Base description (optional)

        indexing_technique : typing.Optional[CreateDatasetRequestIndexingTechnique]
            Indexing mode (optional, recommended)
            - high_quality: High quality
            - economy: Economy

        permission : typing.Optional[CreateDatasetRequestPermission]
            Permission (optional, default only_me)
            - only_me: Only me
            - all_team_members: All team members
            - partial_members: Partial team members

        provider : typing.Optional[CreateDatasetRequestProvider]
            Provider (optional, default vendor)
            - vendor: Upload files
            - external: External knowledge base

        external_knowledge_api_id : typing.Optional[str]
            External knowledge API_ID (optional)

        external_knowledge_id : typing.Optional[str]
            External knowledge ID (optional)

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        Dataset
            Successfully created knowledge base

        Examples
        --------
        import asyncio

        from dify import AsyncDifyApi

        client = AsyncDifyApi(
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.datasets.create_empty_dataset(
                name="name",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            "datasets",
            method="POST",
            json={
                "name": name,
                "description": description,
                "indexing_technique": indexing_technique,
                "permission": permission,
                "provider": provider,
                "external_knowledge_api_id": external_knowledge_api_id,
                "external_knowledge_id": external_knowledge_id,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    Dataset,
                    parse_obj_as(
                        type_=Dataset,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 409:
                raise ConflictError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def view_knowledge_base_details(
        self,
        dataset_id: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> Dataset:
        """
        Get detailed information about a specific knowledge base

        Parameters
        ----------
        dataset_id : str
            Knowledge Base ID

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        Dataset
            Successfully retrieved knowledge base details

        Examples
        --------
        import asyncio

        from dify import AsyncDifyApi

        client = AsyncDifyApi(
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.datasets.view_knowledge_base_details(
                dataset_id="dataset_id",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"datasets/{jsonable_encoder(dataset_id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    Dataset,
                    parse_obj_as(
                        type_=Dataset,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def delete_dataset(
        self,
        dataset_id: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> None:
        """
        Delete specified knowledge base

        Parameters
        ----------
        dataset_id : str
            Knowledge Base ID

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        import asyncio

        from dify import AsyncDifyApi

        client = AsyncDifyApi(
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.datasets.delete_dataset(
                dataset_id="dataset_id",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"datasets/{jsonable_encoder(dataset_id)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def update_knowledge_base_details(
        self,
        dataset_id: str,
        *,
        name: typing.Optional[str] = OMIT,
        indexing_technique: typing.Optional[PatchDatasetsDatasetIdRequestIndexingTechnique] = OMIT,
        permission: typing.Optional[PatchDatasetsDatasetIdRequestPermission] = OMIT,
        embedding_model_provider: typing.Optional[str] = OMIT,
        embedding_model: typing.Optional[str] = OMIT,
        retrieval_model: typing.Optional[str] = OMIT,
        partial_member_list: typing.Optional[typing.Sequence[str]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> Dataset:
        """
        Modify details of a specific knowledge base

        Parameters
        ----------
        dataset_id : str
            Knowledge Base ID

        name : typing.Optional[str]
            Knowledge Base name (optional)

        indexing_technique : typing.Optional[PatchDatasetsDatasetIdRequestIndexingTechnique]
            Indexing mode (optional, recommended)
            - high_quality: High quality
            - economy: Economy

        permission : typing.Optional[PatchDatasetsDatasetIdRequestPermission]
            Permission (optional, default only_me)
            - only_me: Only me
            - all_team_members: All team members
            - partial_members: Partial team members

        embedding_model_provider : typing.Optional[str]
            Embedding model provider (optional), must be configured in the system first, corresponds to the provider field

        embedding_model : typing.Optional[str]
            Embedding model (optional)

        retrieval_model : typing.Optional[str]
            Retrieval model (optional)

        partial_member_list : typing.Optional[typing.Sequence[str]]
            Partial team members ID list (optional)

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        Dataset
            Successfully updated knowledge base details

        Examples
        --------
        import asyncio

        from dify import AsyncDifyApi

        client = AsyncDifyApi(
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.datasets.update_knowledge_base_details(
                dataset_id="dataset_id",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"datasets/{jsonable_encoder(dataset_id)}",
            method="PATCH",
            json={
                "name": name,
                "indexing_technique": indexing_technique,
                "permission": permission,
                "embedding_model_provider": embedding_model_provider,
                "embedding_model": embedding_model,
                "retrieval_model": retrieval_model,
                "partial_member_list": partial_member_list,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    Dataset,
                    parse_obj_as(
                        type_=Dataset,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def retrieve_dataset(
        self,
        dataset_id: str,
        *,
        query: str,
        retrieval_model: typing.Optional[RetrieveDatasetRequestRetrievalModel] = OMIT,
        external_retrieval_model: typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> RetrieveDatasetResponse:
        """
        Retrieve content from specified knowledge base

        Parameters
        ----------
        dataset_id : str
            Knowledge Base ID

        query : str
            Search keyword

        retrieval_model : typing.Optional[RetrieveDatasetRequestRetrievalModel]
            Retrieval parameter configuration

        external_retrieval_model : typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]]
            Unused field

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        RetrieveDatasetResponse
            Retrieval successful

        Examples
        --------
        import asyncio

        from dify import AsyncDifyApi

        client = AsyncDifyApi(
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.datasets.retrieve_dataset(
                dataset_id="dataset_id",
                query="query",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"datasets/{jsonable_encoder(dataset_id)}/retrieve",
            method="POST",
            json={
                "query": query,
                "retrieval_model": convert_and_respect_annotation_metadata(
                    object_=retrieval_model,
                    annotation=RetrieveDatasetRequestRetrievalModel,
                    direction="write",
                ),
                "external_retrieval_model": external_retrieval_model,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    RetrieveDatasetResponse,
                    parse_obj_as(
                        type_=RetrieveDatasetResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)
