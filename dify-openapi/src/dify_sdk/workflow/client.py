# This file was auto-generated by Fern from our API Definition.

import typing
from ..core.client_wrapper import SyncClientWrapper
from .types.run_workflow_request_response_mode import RunWorkflowRequestResponseMode
from ..core.request_options import RequestOptions
from ..types.workflow_message import WorkflowMessage
from ..core.pydantic_utilities import parse_obj_as
from ..errors.bad_request_error import BadRequestError
from ..types.error import Error
from ..errors.not_found_error import NotFoundError
from ..errors.internal_server_error import InternalServerError
from json.decoder import JSONDecodeError
from ..core.api_error import ApiError
from .types.get_workflow_execution_status_response import (
    GetWorkflowExecutionStatusResponse,
)
from ..core.jsonable_encoder import jsonable_encoder
from ..errors.unauthorized_error import UnauthorizedError
from .types.stop_workflow_response import StopWorkflowResponse
from .types.get_workflow_logs_request_status import GetWorkflowLogsRequestStatus
from .types.get_workflow_logs_response import GetWorkflowLogsResponse
from .. import core
from .types.upload_file_response import UploadFileResponse
from ..errors.content_too_large_error import ContentTooLargeError
from ..errors.unsupported_media_type_error import UnsupportedMediaTypeError
from ..errors.service_unavailable_error import ServiceUnavailableError
from .types.get_app_info_response import GetAppInfoResponse
from .types.get_app_parameters_response import GetAppParametersResponse
from ..core.client_wrapper import AsyncClientWrapper

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class WorkflowClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._client_wrapper = client_wrapper

    def run_workflow(
        self,
        *,
        inputs: typing.Dict[str, typing.Optional[typing.Any]],
        response_mode: RunWorkflowRequestResponseMode,
        user: str,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> WorkflowMessage:
        """
        Execute a workflow. Cannot be executed if there is no published workflow.

        Parameters
        ----------
        inputs : typing.Dict[str, typing.Optional[typing.Any]]
            Allows passing values for variables defined in the App.
            The inputs parameter contains multiple key/value pairs, where each key corresponds to a specific variable and each value is the specific value for that variable. Variables can be of file list type.
            File list type variables are suitable for passing files combined with text understanding to answer questions, only available when the model supports parsing capabilities for that type of file. If the variable is a file list type, the value corresponding to the variable should be in list format, where each element should include the following:
              - `type` (string) Supported types:
                - `document` Specific types include: 'TXT', 'MD', 'MARKDOWN', 'PDF', 'HTML', 'XLSX', 'XLS', 'DOCX', 'CSV', 'EML', 'MSG', 'PPTX', 'PPT', 'XML', 'EPUB'
                - `image` Specific types include: 'JPG', 'JPEG', 'PNG', 'GIF', 'WEBP', 'SVG'
                - `audio` Specific types include: 'MP3', 'M4A', 'WAV', 'WEBM', 'AMR'
                - `video` Specific types include: 'MP4', 'MOV', 'MPEG', 'MPGA'
                - `custom` Specific types include: other file types
              - `transfer_method` (string) Transfer method, `remote_url` image address / `local_file` uploaded file
              - `url` (string) Image address (only when the transfer method is `remote_url`)
              - `upload_file_id` (string) Upload file ID (only when the transfer method is `local_file`)

        response_mode : RunWorkflowRequestResponseMode
            Response mode, supports:
            - `streaming` Streaming mode (recommended). Implements streaming return similar to typewriter output based on SSE (Server-Sent Events).
            - `blocking` Blocking mode, waits for execution to complete before returning results. (Requests may be interrupted if the process is lengthy).
            Due to Cloudflare limitations, requests will be interrupted after 100 seconds of timeout with no response.

        user : str
            User identifier, used to define the identity of the end user, for easy retrieval and statistics.
            Rules defined by the developer, the user identifier must be unique within the application.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        WorkflowMessage
            Successful response

        Examples
        --------
        from dify import DifyApi

        client = DifyApi(
            token="YOUR_TOKEN",
        )
        client.workflow.run_workflow(
            inputs={"key": "value"},
            response_mode="streaming",
            user="user",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "workflows/run",
            method="POST",
            json={
                "inputs": inputs,
                "response_mode": response_mode,
                "user": user,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    WorkflowMessage,
                    parse_obj_as(
                        type_=WorkflowMessage,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_workflow_execution_status(
        self,
        workflow_run_id: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> GetWorkflowExecutionStatusResponse:
        """
        Get the current execution result of a workflow task based on the workflow execution ID

        Parameters
        ----------
        workflow_run_id : str
            Workflow run ID, can be obtained from the streaming response chunks

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        GetWorkflowExecutionStatusResponse
            Successfully retrieved workflow execution status

        Examples
        --------
        from dify import DifyApi

        client = DifyApi(
            token="YOUR_TOKEN",
        )
        client.workflow.get_workflow_execution_status(
            workflow_run_id="workflow_run_id",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"workflows/run/{jsonable_encoder(workflow_run_id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    GetWorkflowExecutionStatusResponse,
                    parse_obj_as(
                        type_=GetWorkflowExecutionStatusResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def stop_workflow(
        self,
        task_id: str,
        *,
        user: str,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> StopWorkflowResponse:
        """
        Only supports streaming mode

        Parameters
        ----------
        task_id : str
            Task ID, can be obtained from the streaming response chunks

        user : str
            User identifier, must be consistent with the user passed in the message sending interface

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        StopWorkflowResponse
            Successfully stopped the response

        Examples
        --------
        from dify import DifyApi

        client = DifyApi(
            token="YOUR_TOKEN",
        )
        client.workflow.stop_workflow(
            task_id="task_id",
            user="user",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"workflows/tasks/{jsonable_encoder(task_id)}/stop",
            method="POST",
            json={
                "user": user,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    StopWorkflowResponse,
                    parse_obj_as(
                        type_=StopWorkflowResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_workflow_logs(
        self,
        *,
        keyword: typing.Optional[str] = None,
        status: typing.Optional[GetWorkflowLogsRequestStatus] = None,
        page: typing.Optional[int] = None,
        limit: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> GetWorkflowLogsResponse:
        """
        Return workflow logs in reverse order

        Parameters
        ----------
        keyword : typing.Optional[str]
            Keyword

        status : typing.Optional[GetWorkflowLogsRequestStatus]
            Execution status: succeeded/failed/stopped

        page : typing.Optional[int]
            Current page number, default 1

        limit : typing.Optional[int]
            Items per page, default 20

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        GetWorkflowLogsResponse
            Successfully retrieved workflow logs

        Examples
        --------
        from dify import DifyApi

        client = DifyApi(
            token="YOUR_TOKEN",
        )
        client.workflow.get_workflow_logs()
        """
        _response = self._client_wrapper.httpx_client.request(
            "workflows/logs",
            method="GET",
            params={
                "keyword": keyword,
                "status": status,
                "page": page,
                "limit": limit,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    GetWorkflowLogsResponse,
                    parse_obj_as(
                        type_=GetWorkflowLogsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def upload_file(
        self,
        *,
        file: core.File,
        user: str,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> UploadFileResponse:
        """
        Upload a file to use when sending messages, enabling multimodal understanding. Supports any format supported by your workflow. Uploaded files are only available to the current end user.

        Parameters
        ----------
        file : core.File
            See core.File for more documentation

        user : str
            User identifier, used to define the identity of the end user, must be consistent with the user passed in the message sending interface

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        UploadFileResponse
            File uploaded successfully

        Examples
        --------
        from dify import DifyApi

        client = DifyApi(
            token="YOUR_TOKEN",
        )
        client.workflow.upload_file(
            user="user",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "files/upload",
            method="POST",
            data={
                "user": user,
            },
            files={
                "file": file,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    UploadFileResponse,
                    parse_obj_as(
                        type_=UploadFileResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 413:
                raise ContentTooLargeError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 415:
                raise UnsupportedMediaTypeError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 503:
                raise ServiceUnavailableError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_app_info(self, *, request_options: typing.Optional[RequestOptions] = None) -> GetAppInfoResponse:
        """
        Used to get basic information about the application

        Parameters
        ----------
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        GetAppInfoResponse
            Successfully retrieved application information

        Examples
        --------
        from dify import DifyApi

        client = DifyApi(
            token="YOUR_TOKEN",
        )
        client.workflow.get_app_info()
        """
        _response = self._client_wrapper.httpx_client.request(
            "info",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    GetAppInfoResponse,
                    parse_obj_as(
                        type_=GetAppInfoResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_app_parameters(
        self, *, request_options: typing.Optional[RequestOptions] = None
    ) -> GetAppParametersResponse:
        """
        Used at the beginning of page entry to get feature switches, input parameter names, types, and default values

        Parameters
        ----------
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        GetAppParametersResponse
            Successfully retrieved application parameters

        Examples
        --------
        from dify import DifyApi

        client = DifyApi(
            token="YOUR_TOKEN",
        )
        client.workflow.get_app_parameters()
        """
        _response = self._client_wrapper.httpx_client.request(
            "parameters",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    GetAppParametersResponse,
                    parse_obj_as(
                        type_=GetAppParametersResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)


class AsyncWorkflowClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._client_wrapper = client_wrapper

    async def run_workflow(
        self,
        *,
        inputs: typing.Dict[str, typing.Optional[typing.Any]],
        response_mode: RunWorkflowRequestResponseMode,
        user: str,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> WorkflowMessage:
        """
        Execute a workflow. Cannot be executed if there is no published workflow.

        Parameters
        ----------
        inputs : typing.Dict[str, typing.Optional[typing.Any]]
            Allows passing values for variables defined in the App.
            The inputs parameter contains multiple key/value pairs, where each key corresponds to a specific variable and each value is the specific value for that variable. Variables can be of file list type.
            File list type variables are suitable for passing files combined with text understanding to answer questions, only available when the model supports parsing capabilities for that type of file. If the variable is a file list type, the value corresponding to the variable should be in list format, where each element should include the following:
              - `type` (string) Supported types:
                - `document` Specific types include: 'TXT', 'MD', 'MARKDOWN', 'PDF', 'HTML', 'XLSX', 'XLS', 'DOCX', 'CSV', 'EML', 'MSG', 'PPTX', 'PPT', 'XML', 'EPUB'
                - `image` Specific types include: 'JPG', 'JPEG', 'PNG', 'GIF', 'WEBP', 'SVG'
                - `audio` Specific types include: 'MP3', 'M4A', 'WAV', 'WEBM', 'AMR'
                - `video` Specific types include: 'MP4', 'MOV', 'MPEG', 'MPGA'
                - `custom` Specific types include: other file types
              - `transfer_method` (string) Transfer method, `remote_url` image address / `local_file` uploaded file
              - `url` (string) Image address (only when the transfer method is `remote_url`)
              - `upload_file_id` (string) Upload file ID (only when the transfer method is `local_file`)

        response_mode : RunWorkflowRequestResponseMode
            Response mode, supports:
            - `streaming` Streaming mode (recommended). Implements streaming return similar to typewriter output based on SSE (Server-Sent Events).
            - `blocking` Blocking mode, waits for execution to complete before returning results. (Requests may be interrupted if the process is lengthy).
            Due to Cloudflare limitations, requests will be interrupted after 100 seconds of timeout with no response.

        user : str
            User identifier, used to define the identity of the end user, for easy retrieval and statistics.
            Rules defined by the developer, the user identifier must be unique within the application.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        WorkflowMessage
            Successful response

        Examples
        --------
        import asyncio

        from dify import AsyncDifyApi

        client = AsyncDifyApi(
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.workflow.run_workflow(
                inputs={"key": "value"},
                response_mode="streaming",
                user="user",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            "workflows/run",
            method="POST",
            json={
                "inputs": inputs,
                "response_mode": response_mode,
                "user": user,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    WorkflowMessage,
                    parse_obj_as(
                        type_=WorkflowMessage,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_workflow_execution_status(
        self,
        workflow_run_id: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> GetWorkflowExecutionStatusResponse:
        """
        Get the current execution result of a workflow task based on the workflow execution ID

        Parameters
        ----------
        workflow_run_id : str
            Workflow run ID, can be obtained from the streaming response chunks

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        GetWorkflowExecutionStatusResponse
            Successfully retrieved workflow execution status

        Examples
        --------
        import asyncio

        from dify import AsyncDifyApi

        client = AsyncDifyApi(
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.workflow.get_workflow_execution_status(
                workflow_run_id="workflow_run_id",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"workflows/run/{jsonable_encoder(workflow_run_id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    GetWorkflowExecutionStatusResponse,
                    parse_obj_as(
                        type_=GetWorkflowExecutionStatusResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def stop_workflow(
        self,
        task_id: str,
        *,
        user: str,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> StopWorkflowResponse:
        """
        Only supports streaming mode

        Parameters
        ----------
        task_id : str
            Task ID, can be obtained from the streaming response chunks

        user : str
            User identifier, must be consistent with the user passed in the message sending interface

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        StopWorkflowResponse
            Successfully stopped the response

        Examples
        --------
        import asyncio

        from dify import AsyncDifyApi

        client = AsyncDifyApi(
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.workflow.stop_workflow(
                task_id="task_id",
                user="user",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"workflows/tasks/{jsonable_encoder(task_id)}/stop",
            method="POST",
            json={
                "user": user,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    StopWorkflowResponse,
                    parse_obj_as(
                        type_=StopWorkflowResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_workflow_logs(
        self,
        *,
        keyword: typing.Optional[str] = None,
        status: typing.Optional[GetWorkflowLogsRequestStatus] = None,
        page: typing.Optional[int] = None,
        limit: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> GetWorkflowLogsResponse:
        """
        Return workflow logs in reverse order

        Parameters
        ----------
        keyword : typing.Optional[str]
            Keyword

        status : typing.Optional[GetWorkflowLogsRequestStatus]
            Execution status: succeeded/failed/stopped

        page : typing.Optional[int]
            Current page number, default 1

        limit : typing.Optional[int]
            Items per page, default 20

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        GetWorkflowLogsResponse
            Successfully retrieved workflow logs

        Examples
        --------
        import asyncio

        from dify import AsyncDifyApi

        client = AsyncDifyApi(
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.workflow.get_workflow_logs()


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            "workflows/logs",
            method="GET",
            params={
                "keyword": keyword,
                "status": status,
                "page": page,
                "limit": limit,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    GetWorkflowLogsResponse,
                    parse_obj_as(
                        type_=GetWorkflowLogsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def upload_file(
        self,
        *,
        file: core.File,
        user: str,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> UploadFileResponse:
        """
        Upload a file to use when sending messages, enabling multimodal understanding. Supports any format supported by your workflow. Uploaded files are only available to the current end user.

        Parameters
        ----------
        file : core.File
            See core.File for more documentation

        user : str
            User identifier, used to define the identity of the end user, must be consistent with the user passed in the message sending interface

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        UploadFileResponse
            File uploaded successfully

        Examples
        --------
        import asyncio

        from dify import AsyncDifyApi

        client = AsyncDifyApi(
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.workflow.upload_file(
                user="user",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            "files/upload",
            method="POST",
            data={
                "user": user,
            },
            files={
                "file": file,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    UploadFileResponse,
                    parse_obj_as(
                        type_=UploadFileResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 413:
                raise ContentTooLargeError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 415:
                raise UnsupportedMediaTypeError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 503:
                raise ServiceUnavailableError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_app_info(self, *, request_options: typing.Optional[RequestOptions] = None) -> GetAppInfoResponse:
        """
        Used to get basic information about the application

        Parameters
        ----------
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        GetAppInfoResponse
            Successfully retrieved application information

        Examples
        --------
        import asyncio

        from dify import AsyncDifyApi

        client = AsyncDifyApi(
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.workflow.get_app_info()


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            "info",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    GetAppInfoResponse,
                    parse_obj_as(
                        type_=GetAppInfoResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_app_parameters(
        self, *, request_options: typing.Optional[RequestOptions] = None
    ) -> GetAppParametersResponse:
        """
        Used at the beginning of page entry to get feature switches, input parameter names, types, and default values

        Parameters
        ----------
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        GetAppParametersResponse
            Successfully retrieved application parameters

        Examples
        --------
        import asyncio

        from dify import AsyncDifyApi

        client = AsyncDifyApi(
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.workflow.get_app_parameters()


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            "parameters",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    GetAppParametersResponse,
                    parse_obj_as(
                        type_=GetAppParametersResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)
